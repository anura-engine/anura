/*
	Copyright (C) 2003-2013 by David White <davewx7@gmail.com>
	
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#if defined(USE_SHADERS)
#include "formula_callable_definition.hpp"
#include "formula_function_registry.hpp"
#include "isoworld.hpp"
#include "object_events.hpp"
#include "user_voxel_object.hpp"
#include "voxel_object.hpp"
#include "voxel_object_functions.hpp"

void voxel_object_command_callable::set_expression(const game_logic::formula_expression* expr)
{
	expr_ = expr;
	expr_holder_.reset(expr);
}


void voxel_object_command_callable::run_command(voxel::world& lvl, voxel::user_voxel_object& obj) const
{
	if(expr_) {
		try {
			fatal_assert_scope scope;
			execute(lvl, obj);
		} catch(fatal_assert_failure_exception& e) {
			ASSERT_FATAL(e.msg << "\nERROR ENCOUNTERED WHILE RUNNING COMMAND GENERATED BY THIS EXPRESSION:\n" << expr_->debug_pinpoint_location());
		}
	} else {
		execute(lvl, obj);
	}
}

using namespace game_logic;

namespace {

const std::string FunctionModule = "voxel_object";

class schedule_command : public voxel_object_command_callable 
{
public:
	schedule_command(int cycles, variant cmd) : cycles_(cycles), cmd_(cmd)
	{}

	virtual void execute(voxel::world& lvl, voxel::user_voxel_object& ob) const 
	{
		ob.add_scheduled_command(cycles_, cmd_);
	}
private:
	int cycles_;
	variant cmd_;
};

FUNCTION_DEF(schedule, 2, 2, "schedule(int cycles_in_future, list of commands): schedules the given list of commands to be run on the current object the given number of cycles in the future. Note that the object must be valid (not destroyed) and still present in the level for the commands to be run.")
	schedule_command* cmd = new schedule_command(EVAL_ARG(0).as_int(),EVAL_ARG(1));
	cmd->set_expression(this);
	return variant(cmd);
FUNCTION_ARGS_DEF
	ARG_TYPE("int")
	ARG_TYPE("commands")
	RETURN_TYPE("commands")
END_FUNCTION_DEF(schedule)

static int event_depth = 0;
struct event_depth_scope 
{
	event_depth_scope() 
	{ 
		++event_depth;
	}
	~event_depth_scope() 
	{ 
		--event_depth;
	}
};

class fire_event_command : public voxel_object_command_callable 
{
	const voxel::user_voxel_object_ptr target_;
	const std::string event_;
	const const_formula_callable_ptr callable_;
public:
	fire_event_command(voxel::user_voxel_object_ptr target, const std::string& event, const_formula_callable_ptr callable)
	  : target_(target), event_(event), callable_(callable)
	{}

	virtual void execute(voxel::world& lvl, voxel::user_voxel_object& ob) const
	{
		ASSERT_LOG(event_depth < 1000, "INFINITE (or too deep?) RECURSION FOR EVENT " << event_);
		event_depth_scope scope;
		voxel::user_voxel_object* e = target_ ? target_.get() : &ob;
		e->handle_event(event_, callable_.get());
	}
};

FUNCTION_DEF(fire_event, 1, 3, "fire_event((optional) object target, string id, (optional)callable arg): fires the event with the given id. Targets the current object by default, or target if given. Sends arg as the event argument if given")
	voxel::user_voxel_object_ptr target;
	std::string event;
	const_formula_callable_ptr callable;
	variant arg_value;

	if(args().size() == 3) {
		variant v1 = args()[0]->evaluate(variables);
		if(v1.is_null()) {
			return variant();
		}

		target = v1.convert_to<voxel::user_voxel_object>();
		event = args()[1]->evaluate(variables).as_string();

		arg_value = args()[2]->evaluate(variables);
	} else if(args().size() == 2) {
		variant v1 = args()[0]->evaluate(variables);
		if(v1.is_null()) {
			return variant();
		}

		variant v2 = args()[1]->evaluate(variables);
		if(v1.is_string()) {
			event = v1.as_string();
			arg_value = v2;
		} else {
			target = v1.convert_to<voxel::user_voxel_object>();
			event = v2.as_string();
		}
	} else {
		event = args()[0]->evaluate(variables).as_string();
	}

	variant_type_ptr arg_type = get_object_event_arg_type(get_object_event_id(event));
	if(arg_type) {
		ASSERT_LOG(arg_type->match(arg_value), "Calling fire_event, arg type does not match. Expected " << arg_type->to_string() << " found " << arg_value.write_json() << " which is a " << get_variant_type_from_value(arg_value)->to_string());
	}

	if(arg_value.is_null() == false) {
		callable = map_into_callable(arg_value);
	}

	fire_event_command* cmd = (new fire_event_command(target, event, callable));
	cmd->set_expression(this);
	return variant(cmd);
FUNCTION_ARGS_DEF
	ARG_TYPE("object|string")
	ARG_TYPE("any")
	ARG_TYPE("any")
RETURN_TYPE("commands")
END_FUNCTION_DEF(fire_event)


/*class spawn_voxel_command : public voxel_object_command_callable
{
public:
	spawn_voxel_command(voxel::user_voxel_object_ptr obj, variant instantiation_commands)
	  : obj_(obj), instantiation_commands_(instantiation_commands)
	{}
	virtual void execute(voxel::world& lvl, voxel::voxel_object& ob) const {

		lvl.add_object(obj_);

		obj_->execute_command(instantiation_commands_);
	}
private:
	voxel::user_voxel_object_ptr obj_;
	variant instantiation_commands_;
};

FUNCTION_DEF(spawn_voxel, 4, 6, "spawn_voxel(string type_id, decimal x, decimal y, decimal z, (optional) properties, (optional) list of commands cmd): will create a new object of type given by type_id with the given midpoint and facing. Immediately after creation the object will have any commands given by cmd executed on it. The child object will have the spawned event sent to it, and the parent object will have the child_spawned event sent to it.")

	formula::fail_if_static_context();

	const std::string type = EVAL_ARG(0).as_string();
	const float x = float(EVAL_ARG(1).as_decimal().as_float());
	const float y = float(EVAL_ARG(2).as_decimal().as_float());
	const float z = float(EVAL_ARG(3).as_decimal().as_float());

	variant arg4 = EVAL_ARG(4);

	voxel::user_voxel_object_ptr obj(new voxel::user_voxel_object(type, x, y, z));

	variant commands;
	spawn_voxel_command* cmd = (new spawn_voxel_command(obj, commands));
	cmd->set_expression(this);
	return variant(cmd);
FUNCTION_ARGS_DEF
	//ASSERT_LOG(false, "spawn() not supported in strict mode " << debug_pinpoint_location());
	ARG_TYPE("string")
	ARG_TYPE("decimal")
	ARG_TYPE("decimal")
	ARG_TYPE("decimal")
	ARG_TYPE("map")
	ARG_TYPE("commands")

	variant v;
	if(args()[0]->can_reduce_to_variant(v) && v.is_string()) {
		game_logic::formula_callable_definition_ptr type_def = custom_object_type::get_definition(v.as_string());
		const custom_object_callable* type = dynamic_cast<const custom_object_callable*>(type_def.get());
		ASSERT_LOG(type, "Illegal object type: " << v.as_string() << " " << debug_pinpoint_location());

		if(args().size() > 3) {
			variant_type_ptr map_type = args()[3]->query_variant_type();
			assert(map_type);

			const std::map<variant, variant_type_ptr>* props = map_type->is_specific_map();
			if(props) {
				foreach(int slot, type->slots_requiring_initialization()) {
					const std::string& prop_id = type->get_entry(slot)->id;
					ASSERT_LOG(props->count(variant(prop_id)), "Must initialize " << v.as_string() << "." << prop_id << " " << debug_pinpoint_location());
				}

				for(std::map<variant,variant_type_ptr>::const_iterator itor = props->begin(); itor != props->end(); ++itor) {
					const int slot = type->get_slot(itor->first.as_string());
					ASSERT_LOG(slot >= 0, "Unknown property " << v.as_string() << "." << itor->first.as_string() << " " << debug_pinpoint_location());

					const formula_callable_definition::entry& entry = *type->get_entry(slot);
					ASSERT_LOG(variant_types_compatible(entry.get_write_type(), itor->second), "Initializing property " << v.as_string() << "." << itor->first.as_string() << " with type " << itor->second->to_string() << " when " << entry.get_write_type()->to_string() << " is expected " << debug_pinpoint_location());
				}
			}
		}

		ASSERT_LOG(type->slots_requiring_initialization().empty() || args().size() > 3 && args()[3]->query_variant_type()->is_map_of().first, "Illegal spawn of " << v.as_string() << " property " << type->get_entry(type->slots_requiring_initialization()[0])->id << " requires initialization " << debug_pinpoint_location());
	}
RETURN_TYPE("commands")
END_FUNCTION_DEF(spawn_voxel)
*/


class voxel_object_function_symbol_table : public function_symbol_table
{
public:
	expression_ptr create_function(const std::string& fn,
		const std::vector<expression_ptr>& args,
		const_formula_callable_definition_ptr callable_def) const
	{
		const std::map<std::string, function_creator*>& creators = get_function_creators(FunctionModule);
		std::map<std::string, function_creator*>::const_iterator i = creators.find(fn);
		if(i != creators.end()) {
			return expression_ptr(i->second->create(args));
		}

		return function_symbol_table::create_function(fn, args, callable_def);
	}

};

}

function_symbol_table& get_voxel_object_functions_symbol_table()
{
	static voxel_object_function_symbol_table table;
	return table;
}

#endif // USE_SHADERS
